---
title: Use code coverage for unit testing
description: Learn how to use the code coverage capabilities for .NET unit tests.
author: IEvangelist
ms.author: dapine
ms.date: 06/15/2020
---

# Use code coverage for unit testing

Unit tests help to ensure functionality, and provide a means of verification for refactoring efforts. Code coverage is a measurement of the amount of code that is run by unit tests - either lines, branches, or methods. As an example, if you have a simple application with only two conditional branches of code (_branch a_, and _branch b_), a unit test that verifies conditional _branch a_ will report branch code coverage of 50%.

This article discusses the usage of code coverage for unit testing with coverlet. Coverlet is an [open source project on GitHub](https://github.com/coverlet-coverage/coverlet) that provides a cross platform code coverage framework for .NET. [Coverlet](https://dotnetfoundation.org/projects/coverlet) is part of the .NET foundation. Coverlet does not support F# or Visual Basic, as such this article is scoped C# and xUnit. Additionally, this article details how to use the code coverage information collected from test runs to generate reports using [ReportGenerator](https://github.com/danielpalme/ReportGenerator). ReportGenerator converts coverage reports generated by OpenCover, dotCover, Visual Studio, NCover, Cobertura, JaCoCo, Clover, gcov, or lcov into human readable reports in various formats.

## Tooling

There are several tooling aspects of unit testing code coverage for consideration:

- **DataCollectors:** DataCollectors are used to monitor test execution. They collect generated information about test runs in various output formats, XML, JSON, etc. For more information, see [your first DataCollector](https://github.com/Microsoft/vstest-docs/blob/master/docs/extensions/datacollector.md).
- **Report generators:** Use data collected from test runs to generate reports, often as styled HTML.

In this section, the focus is on data collector tools. To use coverlet for code coverage, an existing unit test project must have the appropriate package dependencies, or alternatively rely on [.NET global tooling](../tools/global-tools.md).

## Integrate with .NET test

To integrate with [`dotnet test`](../tools/dotnet-test.md), add the appropriate package dependency. From the directory of the *.csproj* file, run the following [`dotnet add package`](../tools/dotnet-add-package.md) command:

```dotnetcli
dotnet add package coverlet.collector
```

The [coverlet.collector](https://www.nuget.org/packages/coverlet.collector) NuGet package is added to the project. Next, run the following command:

```dotnetcli
dotnet test --collect:"XPlat Code Coverage"
```

> [!IMPORTANT]
> The `"XPlat Code Coverage"` argument is a friendly name that corresponds to the data collectors from coverlet. This name is required but is case insensitive.

As part of the `dotnet test` run, a resulting *coverage.cobertura.xml* file is output to the *TestResults* directory. The XML file contains the results. This is a cross platform option that relies on the .NET Core CLI, and it great for build systems where MSBuild is not available.

Below is the example *coverage.json* file from the corresponding sample repo.

```xml
<?xml version="1.0" encoding="utf-8"?>
<coverage line-rate="1" branch-rate="1" version="1.9" timestamp="1592248008" lines-covered="12" lines-valid="12" branches-covered="6" branches-valid="6">
  <sources>
    <source>C:\</source>
  </sources>
  <packages>
    <package name="Numbers" line-rate="1" branch-rate="1" complexity="6">
      <classes>
        <class name="Numbers.PrimeService" filename="..samples\csharp\unit-testing\Numbers\PrimeService.cs" line-rate="1" branch-rate="1" complexity="6">
          <methods>
            <method name="IsPrime" signature="(System.Int32)" line-rate="1" branch-rate="1" complexity="6">
              <lines>
                <line number="8" hits="11" branch="False" />
                <line number="9" hits="11" branch="True" condition-coverage="100% (2/2)">
                  <conditions>
                    <condition number="7" type="jump" coverage="100%" />
                  </conditions>
                </line>
                <line number="10" hits="3" branch="False" />
                <line number="11" hits="3" branch="False" />
                <line number="14" hits="22" branch="True" condition-coverage="100% (2/2)">
                  <conditions>
                    <condition number="57" type="jump" coverage="100%" />
                  </conditions>
                </line>
                <line number="15" hits="7" branch="False" />
                <line number="16" hits="7" branch="True" condition-coverage="100% (2/2)">
                  <conditions>
                    <condition number="27" type="jump" coverage="100%" />
                  </conditions>
                </line>
                <line number="17" hits="4" branch="False" />
                <line number="18" hits="4" branch="False" />
                <line number="20" hits="3" branch="False" />
                <line number="21" hits="4" branch="False" />
                <line number="23" hits="11" branch="False" />
              </lines>
            </method>
          </methods>
          <lines>
            <line number="8" hits="11" branch="False" />
            <line number="9" hits="11" branch="True" condition-coverage="100% (2/2)">
              <conditions>
                <condition number="7" type="jump" coverage="100%" />
              </conditions>
            </line>
            <line number="10" hits="3" branch="False" />
            <line number="11" hits="3" branch="False" />
            <line number="14" hits="22" branch="True" condition-coverage="100% (2/2)">
              <conditions>
                <condition number="57" type="jump" coverage="100%" />
              </conditions>
            </line>
            <line number="15" hits="7" branch="False" />
            <line number="16" hits="7" branch="True" condition-coverage="100% (2/2)">
              <conditions>
                <condition number="27" type="jump" coverage="100%" />
              </conditions>
            </line>
            <line number="17" hits="4" branch="False" />
            <line number="18" hits="4" branch="False" />
            <line number="20" hits="3" branch="False" />
            <line number="21" hits="4" branch="False" />
            <line number="23" hits="11" branch="False" />
          </lines>
        </class>
      </classes>
    </package>
  </packages>
</coverage>
```

### MSBuild

As an alternative, you could use the MSBuild package if your build system already makes use of MSBuild. From a command prompt in the project directory, run the following [`dotnet add package`](../tools/dotnet-add-package.md) command:

```dotnetcli
dotnet add package coverlet.msbuild
```

The [coverlet.msbuild](https://www.nuget.org/packages/coverlet.msbuild) NuGet package is added to the project. Next, run the following command:

```dotnetcli
dotnet test /p:CollectCoverage=true
```

Below is the example *coverage.json* file from the corresponding sample repo.

```json
{
  "Numbers.dll": {
    "..\\samples\\csharp\\unit-testing\\Numbers\\PrimeService.cs": {
      "Numbers.PrimeService": {
        "System.Boolean Numbers.PrimeService::IsPrime(System.Int32)": {
          "Lines": {
            "8": 11,
            "9": 11,
            "10": 3,
            "11": 3,
            "14": 22,
            "15": 7,
            "16": 7,
            "17": 4,
            "18": 4,
            "20": 3,
            "21": 4,
            "23": 11
          },
          "Branches": [
            {
              "Line": 9,
              "Offset": 7,
              "EndOffset": 9,
              "Path": 0,
              "Ordinal": 0,
              "Hits": 3
            },
            {
              "Line": 9,
              "Offset": 7,
              "EndOffset": 14,
              "Path": 1,
              "Ordinal": 1,
              "Hits": 8
            },
            {
              "Line": 14,
              "Offset": 57,
              "EndOffset": 18,
              "Path": 1,
              "Ordinal": 5,
              "Hits": 7
            },
            {
              "Line": 16,
              "Offset": 27,
              "EndOffset": 29,
              "Path": 0,
              "Ordinal": 2,
              "Hits": 4
            },
            {
              "Line": 16,
              "Offset": 27,
              "EndOffset": 34,
              "Path": 1,
              "Ordinal": 3,
              "Hits": 3
            },
            {
              "Line": 14,
              "Offset": 57,
              "EndOffset": 59,
              "Path": 0,
              "Ordinal": 4,
              "Hits": 4
            }
          ]
        }
      }
    }
  }
}
```

> [!NOTE]
> There is a subtle difference in the output between the two `dotnet test` commands. The first output was an XML file, whereas the last is a JSON file.

## Use with .NET global tooling

To use coverlet globally, it can be installed as a [.NET global tool](../tools/global-tools.md). Run the following [`dotnet tool install`](../tools/dotnet-tool-install.md) command:

```dotnetcli
dotnet tool install --global coverlet.console
```

The [coverlet.console](https://www.nuget.org/packages/coverlet.console) NuGet package is added to the environment globally. Now, `coverlet` can be used as a CLI command:

```console
coverlet C:\Source\Directory\bin\Debug\netcoreapp3.1\Test.dll --target "dotnet" --targetargs "test . --no-build"
```

## Generate reports

Now that you're able to collect data from unit test runs, you can generate reports using [ReportGenerator](https://github.com/danielpalme/ReportGenerator). First, install the [ReportGenerator](https://www.nuget.org/packages/dotnet-reportgenerator-globaltool) NuGet package as a [.NET global tool](../tools/global-tools.md) using the [`dotnet tool install`](../tools/dotnet-tool-install.md) command:

```dotnetcli
dotnet tool install -g dotnet-reportgenerator-globaltool
```

Run the tool and provide the desired options, given the output from a test run.

```console

```

## See also

- [Visual Studio unit test cover coverage](/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested)
- [GitHub - Coverlet repository](https://github.com/coverlet-coverage/coverlet)
- [GitHub - ReportGenerator repository](https://github.com/danielpalme/ReportGenerator)
- [ReportGenerator project site](https://danielpalme.github.io/ReportGenerator)
- [.NET Core CLI test command](../tools/dotnet-test.md)

## Next Steps

> [!div class="nextstepaction"]
> [Unit testing best practices](unit-testing-best-practices.md)
